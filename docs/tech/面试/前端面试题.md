---
title: "前端面试题"
sidebarDepth: 2
---

### CSS

#### 清除浮动

把 .clearfix 添加到容器上，里面的子元素就会清除浮动

```
 .clearfix:after {
    content: "";
    display: block; /*或者 table*/
    clear: both;
 }
 .clearfix {
    zoom: 1; /* IE 兼容*/
 }
```

### JS

#### 防抖和节流

- 函数防抖(debounce)，指的是短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行
- 函数节流(throttle)，指连续触发事件但是在 n 秒中只执行一次函数

#### 深拷贝和浅拷贝

- 浅拷贝：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做浅拷贝（浅复制）
  浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。

- 深拷贝：在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响。

#### 宏任务和微任务

- 常见的宏任务有：setTimeout、setInterval、requestAnimationFrame、script 等。
- 常见的微任务有：new Promise( ).then(回调)、MutationObserver  等。

宏任务和微任务的执行流程，总结起来就是：  
js 在调用时，优先取出微任务，并且在执行过程中如果创建了新的作业，则放在本次执行完后紧接着调用，微任务执行完成后，再取出宏任务执行

### 浏览器

#### 输入 url 后按下回车会发生什么

1 解析域名
2 缓存判断 --有资源直接返回、否则向服务器发起新的请求
3 DNS 解析
4 获取 MAC 地址
5 会把请求的内容存储到 dns
6 TCP 三次握手
7 HTTPS 握手
8 返回数据
9 TCP 四次挥手

#### 回流和重绘

网页生成过程：

- HTML 被 HTML 解析器解析成 DOM 树
- css 则被 css 解析器解析成 CSSOM 树
- 结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)
- 生成布局（flow），即将所有渲染树的所有节点进行平面合成
- 将布局绘制（paint）在屏幕上

重排(也称回流):   当 DOM 的变化影响了元素的几何属性（DOM 对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面中正确的位置，这个过程就叫回流。触发：

1. 添加或者删除可见的 DOM 元素
2. 元素尺寸改变——边距、填充、边框、宽度和高度

重绘： 当一个元素的外观发生了改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘，触发：

- 改变元素的 color、background、box-shadow 属性

#### cookie、sessionStorage、localStorage 的区别

- cookie 可以设置失效时间
- localStorage 除非手动清除，否则永久保存
- sessionStorage 尽在当前网页有效，关闭页面就被清除
- cookie 储存大小是 4k，localStorage 和 sessionStorage 是 5M
- 请求时：cookie 自动携带 HTTP 头部中，localStorage 和 sessionStorage 仅在浏览器保存，不参与服务器通信

#### 跨域

同源策略，协议、端口号、域名必须一致

- jsonp(利用 script 标签没有跨域限制的漏洞实现。缺点：只支持 GET 请求)
- CORS(设置 Access-Control-Allow-Origin：指定可访问资源的域名
- Node 中间件代理
- Nginx 反向代理

#### TCP 三次握手和四次挥手

- TCP 协议通过三次握手建立可靠的点对点连接
  首先服务器进入监听状态，然后即可处理连接
  1. 第一次握手：建立连接时，客户端发送 syn 包到服务器，并进入 SYN_SENT 状态，等待服务器确认。在发送的包中还会包含一个初始序列号 seq。此次握手的含义是客户端希望与服务器建立连接。
  2. 第二次握手：服务器收到 syn 包，然后回应给客户端一个 SYN+ACK 包，此时服务器进入 SYN_RCVD 状态。此次握手的含义是服务端回应客户端，表示已收到并同意客户端的连接请求。
  3. 第三次握手：客户端收到服务器的 SYN 包后，向服务器再次发送 ACK 包，并进入 ESTAB_LISHED 状态。

最后，服务端收到客户端的 ACK 包，于是也进入 ESTAB_LISHED 状态，至此，连接建立完成

- 关闭连接时，需要进行四次握手
  1. Client 向 Server 发送 FIN 包，表示 Client 主动要关闭连接，然后进入 FIN_WAIT_1 状态，等待 Server 返回 ACK 包。此后 Client 不能再向 Server 发送数据，但能读取数据。
  2. Server 收到 FIN 包后向 Client 发送 ACK 包，然后进入 CLOSE_WAIT 状态，此后 Server 不能再读取数据，但可以继续向 Client 发送数据。
  3. Client 收到 Server 返回的 ACK 包后进入 FIN_WAIT_2 状态，等待 Server 发送 FIN 包。
  4. Server 完成数据的发送后，将 FIN 包发送给 Client，然后进入 LAST_ACK 状态，等待 Client 返回 ACK 包，此后 Server 既不能读取数据，也不能发送数据。
  5. Client 收到 FIN 包后向 Server 发送 ACK 包，然后进入 TIME_WAIT 状态，接着等待足够长的时间（2MSL）以确保 Server 接收到 ACK 包，最后回到 CLOSED 状态，释放网络资源。
  6. Server 收到 Client 返回的 ACK 包后便回到 CLOSED 状态，释放网络资源。

### http

#### http 状态码

状态码的类别：

1xx Informational(信息性状态码) 接受的请求正在处理
2xx Success(成功状态码) 请求正常处理完毕
3xx Redirection(重定向状态码) 需要进行附加操作一完成请求
4xx Client Error (客户端错误状态码) 服务器无法处理请求
5xx Server Error(服务器错误状态码) 服务器处理请求出错

#### Http 和 Https 区别

- HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头
- HTTP 是不安全的，而 HTTPS 是安全的
- HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443
- 在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 的安全传输机制工作在传输层
- HTTP 无法加密，而 HTTPS 对传输的数据进行加密
- HTTP 无需证书，而 HTTPS 需要 CA 机构 wosign 的颁发的 SSL 证书

#### GET 和 POST 的区别

从 http 协议的角度来说，GET 和 POST 它们都只是请求行中的第一个单词，除了语义不同，其实没有本质的区别。  
之所以在实际开发中会产生各种区别，主要是因为浏览器的默认行为造成的。  
受浏览器的影响，在实际开发中，GET 和 POST 有以下区别：

- 浏览器在发送 GET 请求时，不会附带请求体
- GET 请求的传递信息量有限，适合传递少量数据；POST 请求的传递信息量是没有限制的，适合传输大量数据。
- GET 请求只能传递 ASCII 数据，遇到非 ASCII 数据需要进行编码；POST 请求没有限制
- 大部分 GET 请求传递的数据都附带在 path 参数中，能够通过分享地址完整的重现页面，但同时也暴露了数据，若有敏感数据传递，不应该使用 GET 请求，至少不应该放到 path 中
- 刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。
- GET 请求的地址可以被保存为浏览器书签，POST 不可以

## 渐进增强 vs. 优雅降级

渐进增强（progressive enhancement）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

优雅降级（graceful degradation）：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。

## TS

### TS 和 JS 的区别
TypeScript

- JavaScript 的超集用于解决大型项目的代码复杂性
- 可以在编译期间发现并纠正错误
- 强类型，支持静态和动态类型
- 最终被编译成 JavaScript 代码，使浏览器可以理解
- 可以直接在浏览器中使用支持模块、泛型和接口
- 社区的支持仍在增长，而且还不是很大

JavaScript

- 一种脚本语言，用于创建动态网页
- 作为一种解释型语言，只能在运行时发现错误
- 弱类型，没有静态类型选项
- 不支持模块，泛型或接口
- 大量的社区支持以及大量文档和解决问题的支持


### TS 中的数据类型

## 前端安全

### XSS 攻击

XSS(Cross-Site Scripting，跨站脚本攻击)是指攻击者在返回的 HTML 中插入 JavaScript 脚本。为了减轻这些攻击，需要在 HTTP 头部配置 set-cookie:

HttpOnly - 这个属性可以防止 cross-site scripting，因为它会禁止 Javascript 脚本访问 cookie。
secure - 这个属性告诉浏览器仅在请求为 HTTPS 时发送 cookie。

结果应该是这样的: Set-Cookie: sid=; HttpOnly. 使用 Express 的话，cookie-session 默认配置好了。

### CSRF 攻击

1. 必考：什么是 XSS？如何预防？
   比较复杂，看我的文章 https://zhuanlan.zhihu.com/p/22500730
2. 必考：什么是 CSRF？如何预防？
   比较复杂，看若愚的文章 https://zhuanlan.zhihu.com/p/22521378

   XSS 和 CSRF：https://ju7ejin.im/entry/5b4b56fd5188251b1a7b2ac1
